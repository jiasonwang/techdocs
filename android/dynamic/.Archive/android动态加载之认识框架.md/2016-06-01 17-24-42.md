## Android动态加载之认识框架
了解android动态加载的过程，首先需要对android的部分框架进行了解，以下对Android的Activity的生命周期进行讲解，然后看如何hook这个过程的细节。
简单概念解释
```table
App一侧
java类型  |   职责解释
ActivityThread  |   Apk运行后每个进程都会生成一个该对象(它有java经典的main方法，算是java层进程开启的地方)，算是和框架交互的核心对象。这个看源码的类注释就可以知道。
IApplicationThread /ApplicationThread |   一个binder对象接口，用于和android服务框架使用该接口和app进行通信，比如AMS通过该接口来通知app进行activity的生命周期管理。
Instrumentation | 这个类，在android测试中非常熟悉，其实它的方法就是提供创建四大组件等对象用的，那么一当你mock了这个对象，那么就可以对系统进行测试了，而从动态加载的角度讲，你要是替换了这个对象，那么你就可以为系统提供指定的act，service对象了，最最重要的是这个类是我们可以继承访问的。
LoadedApk   | 代表了Apk文件的所有信息，包括资源，类加载器等。并且有一个构造Application实例的方法。
ContextImpl | 继承并实现了大部分的Context，Activity里的很多操作都最终转发至这里去做，使用了ContextThemeWrapper的代理模式。impl这个类实现了大部分的资源，文件相关的方法，以及与别的界面，服务的联系（启动其他act），这就是一个app运行的“上下文”本质特征。而且，显然这个对象的实例全进程只要一个就够了。所以在代理模式中，无论是act，service还是application，它们的大部分实现都会委托给impl。
ActivityClientRecord | AMS查询，验证，并建立act的信息后返回给客户端的信息都会被记录到这个对象中，其中有一个IBinder作为token来唯一标识这个act。
Android系统一侧
ActivityManagerNative   | 典型的android binder通信base类，作为服务端的几类以及为客户端提供代理类。主要业务是创建启动act（其他生命周期是通过IApplicationThread调度的），app等。
ActivityManagerService |   android系统管理act的服务，简称AMS，通过IApplicationThread和act进行交互。包括创建app的进程，act，调度act生命周期。
ActivityStackSupervisor | Android act stack的管理类，维护stack，task的生成，销毁，为act的生成做准备，比如启动模式，查找act在哪个task，是否要新建task等等，职责就是实现android典型的act stack概念。
ActivityStack | 单一的一个act堆，里面以Task为基础进行管理act。
TaskRecord | 记录Task实例，里面记录着这个task的关联ActivityRecord列表。
ActivityRecord | android系统侧记录当前存在的act实例。
```
上面的这些概念几乎涵盖了所有Acivity创建和启动的java层，包括app进程和系统框架进程AMS所做的工作，简单描述就是AMS通过binder接口如提线木偶般操控app端的act的生命周期，然后act会做对应的反馈。下面开始开车了：
##开启一个Activity
启动一个act的方法，无非就是两种，一个种是在Launcher界面，单击某个app的icon，然后进入到默认启动的界面（前提是之前没有启动过），还有就是app内部的启动。无论是哪种方式，最终都会使用到Instrumentation.execStartActivity方法,该方法会使用ActivityManagerProxy进行跨进程的方法调用，即binder IPC，大体的调用逻辑图如下(省去了部分调用，分别按几张图展开，因为太复杂了)：
###启动activity前的工作：
![](https://raw.githubusercontent.com/jiasonwang/techdocs/master/android/dynamic/raw/activity%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F%E5%9B%BE1.png)
> 1.ActivityStackSupervisor.startActivityMayWait()方法，该方法主要是查询传递过来的intent的信息，并生成ActivityInfo对象。
> 2.ActivityStackSupervisor.startActivityLocked() ,1中的方法会进一步到这个方法中，这个方法会对将要启动的act做校验，比如上一步传进来的ActivityInfo若为空，则直接返回START_CLASS_NOT_FOUND，然后一直回传到启动app一端的Instrumentation.checkStartActivityResult()方法中，由名字就可以知道作用了，然后检测到时这个err后，就会抛出异常，app就挂了。这个方法还会检测启动它的app的权限，不通过一样也回传错误码。
     在没有错误的情况下，会生成一个ActivityRecord来记录这个act的信息，准备下一步的操作。
> 3.ActivityStackSupervisor.startActivityUncheckedLocked，这方法，开始为act的启动查找合适的task宿主，而这个task宿主又是在activity stack中。act在androidmanifest中设置了诸如singleTop，singleTask等，都会影响宿主task的查找。若是没有指定，那就是standard。在standard情况下，若是从launcher上启动，则需要新建一个task来存放这个act。在ActivityStackSupervisor 对象中有个SparseArray<ActivityDisplay> mActivityDisplays ,ActivityDisplay代表了android系统的屏幕数，所以里面会关联一个或多个ActivityStack，当在查找某个act应该出现在哪个task时，就会遍历这个数组查找。对于new task来说，查找失败，则需要去创建一个task，这个会委托给ActivityStack调用createTaskRecord，这样，这个act就算是找到组织了。
> 4.ActivityStack.startActivityLocked，进入该方法，首先会被要启动的act放在这个task的最前面（addActivityToTop）,以及将自身task设置为前台task（setFrontOfTask()）这个对象里不会有实质的操作，也就是只是设置一些状态而已，然后又会回到ActivityStackSupervisor控制。
> 5.ActivityStackSupervisor.resumeTopActivitiesLocked，ActivityStack.resumeTopActivityLocked,ActivityStack.resumeTopActivityInnerLocked(这里是个调用链，图中省略了),在启动这个act之前，我们需要将启动它的act进行pause处理，这个其实就在处理两个act的生命周期问题了，即一个是pause，一个是onCreate。调用当前resume的act的pause，记录在mResumedActivity变量中.
> 6.ActivityStack.startPausingLocked，置空mResumedActivity，设置当前mPausingActivity值，当然还有一些其他pause相关的辅助变量,然后调用prev.app.thread.schedulePauseActivity，其中thread就是IApplicationThread 。注意，底层ApplicationThreadProxy中实现该方法是FLAG_ONEWAY，也就是非阻塞调用，马上返回。紧接着会会发送一个PAUSE_TIMEOUT_MSG消息给“PAUSE_TIMEOUT=500”后的自己。若这条消息没有被正常删掉，那么500ms后系统将调用completePauseLocked（true）来强制设置为pause状态。

 ###Pause当前act，并启动另一个act的进程（如果不存在）
下面这种时序图是基于之前那张的，也就是看是pause当前的act：
![执行pause](https://raw.githubusercontent.com/jiasonwang/techdocs/master/android/dynamic/raw/activity%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F%E5%9B%BE2.png)
![启动新的app]()
 > 7.ApplicationThread.schedulePauseActivity,ams的进程通过这个iBinder，调用schedulePauseActivity方法，这样在app一端，就会收到对应的同步方法，这个方法会发送消息给主线程处理。
 > 8.ActivityThread.sendMessage,这个就是发送消息的方法，它将消息塞到mH对应的主线程中。
 > 9.ActivityThread.handlePauseActivity，接下去的操作就比较简单了，那就是通过Instrumentation分别调用“保存当前act状体”的方法，以及pause方法，方法名见流程图。这些都处理完成后，需要告诉AMS，app已经处理完成了，接着进行一下步的处理。
 > 10.ActivityManagerNative.activityPaused，通知AMS，Act的pause操作已经完成。
 > 11.ActivityStack.activityPausedLocked,ActivityStack.completePauseLocked，pause的通知会转到paused act所在的stack中，然后会删除掉第6步所设置的超时消息，然后调用completePauseLocked(resumeNext = true)。由于mPausingActivity不为null，所以会处理一些后学的记录，然后将它置为null。由于传入的resumeNext = true，那么接下去就要设置一个act到前台来了，对于ams中，状态为resume的act就是当前显示（或者将要显示）的act，那么调用ActivityStackSupervisor.resumeTopActivitiesLocked(topstack,pre,null)。
 >12.ActivityStackSupervisor.resumeTopActivitiesLocked,ActivityStack.completePauseLocked,ActivityStack.resumeTopActivityInnerLocked,因为涉及到多个display，所以要让ActivityStackSupervisor来统筹处理，然后分发到当前ActivityStack中