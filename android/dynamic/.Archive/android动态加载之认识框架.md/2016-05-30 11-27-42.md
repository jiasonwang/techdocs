## Android动态加载之认识框架
了解android动态加载的过程，首先需要对android的部分框架进行了解，以下对Android的Activity的生命周期进行讲解，然后看如何hook这个过程的细节。
简单概念解释
```table
App一侧
java类型  |   职责解释
ActivityThread  |   Apk运行后每个进程都会生成一个该对象(它有java经典的main方法，算是java层进程开启的地方)，算是和框架交互的核心对象。这个看源码的类注释就可以知道。
IApplicationThread /ApplicationThread |   一个binder对象接口，用于和android服务框架使用该接口和app进行通信，比如AMS通过该接口来通知app进行activity的生命周期管理。
Instrumentation | 这个类，在android测试中非常熟悉，其实它的方法就是提供创建四大组件等对象用的，那么一当你mock了这个对象，那么就可以对系统进行测试了，而从动态加载的角度讲，你要是替换了这个对象，那么你就可以为系统提供指定的act，service对象了，最最重要的是这个类是我们可以继承访问的。
LoadedApk   | 代表了Apk文件的所有信息，包括资源，类加载器等。并且有一个构造Application实例的方法。
ContextImpl | 继承并实现了大部分的Context，Activity里的很多操作都最终转发至这里去做，使用了ContextThemeWrapper的代理模式。impl这个类实现了大部分的资源，文件相关的方法，以及与别的界面，服务的联系（启动其他act），这就是一个app运行的“上下文”本质特征。而且，显然这个对象的实例全进程只要一个就够了。所以在代理模式中，无论是act，service还是application，它们的大部分实现都会委托给impl。
ActivityClientRecord | AMS查询，验证，并建立act的信息后返回给客户端的信息都会被记录到这个对象中，其中有一个IBinder作为token来唯一标识这个act。
Android系统一侧
ActivityManagerNative   | 典型的android binder通信base类，作为服务端的几类以及为客户端提供代理类。主要业务是创建启动act（其他生命周期是通过IApplicationThread调度的），app等。
ActivityManagerService |   android系统管理act的服务，简称AMS，通过IApplicationThread和act进行交互。包括创建app的进程，act，调度act生命周期。
ActivityStackSupervisor | Android act stack的管理类，维护stack，task的生成，销毁，为act的生成做准备，比如启动模式，查找act在哪个task，是否要新建task等等，职责就是实现android典型的act stack概念。
ActivityStack | 单一的一个act堆，里面以Task为基础进行管理act。
TaskRecord | 记录Task实例，里面记录着这个task的关联ActivityRecord列表。
ActivityRecord | android系统侧记录当前存在的act实例。
```
上面的这些概念几乎涵盖了所有Acivity创建和启动的java层，包括app进程和系统框架进程AMS所做的工作，简单描述就是AMS通过binder接口如提线木偶般操控app端的act的生命周期，然后act会做对应的反馈。下面开始开车了：
##开启一个Activity
启动一个act的方法，无非就是两种，一个种是在Launcher界面，单击某个app的icon，然后进入到默认启动的界面（前提是之前没有启动过），还有就是app内部的启动。无论是哪种方式，最终都会使用到Instrumentation.execStartActivity方法,该方法会使用ActivityManagerProxy进行跨进程的方法调用，即binder IPC，大体的调用逻辑图如下(省去了部分调用)：
> 1.ActivityStackSupervisor.startActivityMayWait()方法，该方法主要是查询传递过来的intent的信息，并生成ActivityInfo对象。
> 2.ActivityStackSupervisor.startActivityLocked() ,1中的方法会进一步到这个方法中，这个方法会对将要启动的act做校验，比如上一步传进来的ActivityInfo若为空，则直接返回START_CLASS_NOT_FOUND，然后一直回传到启动app一端的Instrumentation.checkStartActivityResult()方法中，由名字就可以知道作用了，然后检测到时这个err后，就会抛出异常，app就挂了。这个方法还会检测启动它的app的权限，不通过一样也回传错误码。
     在没有错误的情况下，会生成一个ActivityRecord来记录这个act的信息，准备下一步的操作。
> 3.ActivityStackSupervisor.startActivityUncheckedLocked，这方法，开始为act的启动查找合适的task宿主，而这个task宿主又是在activity stack中。act在androidmanifest中设置了诸如singleTop，singleTask等，都会影响宿主task的查找。若是没有指定，那就是standard。在standard情况下，若是从launcher上启动，则需要新建一个task来存放这个act。在ActivityStackSupervisor 对象中有个SparseArray<ActivityDisplay> mActivityDisplays ,ActivityDisplay代表了android系统的屏幕数，所以里面会关联一个或多个ActivityStack，当在查找某个act应该出现在哪个task时，就会遍历这个数组查找。对于new task来说，查找失败，则需要去创建一个task，这个会委托给ActivityStack调用createTaskRecord，这样，这个act就算是找到组织了。
> 4.ActivityStack.startActivityLocked，进入该方法，首先会被要启动的act放在这个task的最前面（addActivityToTop）,以及将自身task设置为前台task（setFrontOfTask()）这个对象里不会有实质的操作，也就是只是设置一些状态而已，然后又会回到ActivityStackSupervisor控制。
> 5.ActivityStackSupervisor.resumeTopActivitiesLocked，ActivityStack.resumeTopActivityLocked,ActivityStack.resumeTopActivityInnerLocked,在启动这个act之前，我们需要将启动它的act进行pause处理，这个其实就在处理两个act的生命周期问题了，即一个是pause，一个是onCreate。先记录下将要启动的act，为mLastStartedActivity = next，然后调用当前resume的act的pause，mResumedAc
 